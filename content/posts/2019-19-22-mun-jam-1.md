---
title: "Mun Jam #1"
author: The Mun Team
excerpt: As we finally found ourselves in the same country, our two-man team decided to get together for a Mun Jam.
date: "2019-09-22T22:12:03.284Z"
---

As we finally found ourselves in the same country, our two-man team decided to get together for a
Mun Jam. Our goal? Define an ABI for sharing function and type information between the
Mun compiler and runtime, allowing us to integrate both components into a single pipeline.
In Mun, a single file or group of files is compiled into - what we call - an assembly that can be
hot reloaded at runtime. To guarantee that argument and return types of functions in different
assemblies correspond, we need to expose their function and type information. The Application
Binary Interface (ABI) that is used to express these so-called symbols adheres to the C ABI, to
make it easier to integrate Mun with other programming languages. 

```c
#ifndef MUN_ABI_H_
#define MUN_ABI_H_

#include <stdint.h>

typedef struct
{
    uint8_t b[16];
} MunGuid;

typedef struct
{
    MunGuid guid;
    const char *name;
} MunTypeInfo;

typedef enum
{
    MunPrivacyPublic = 0,
    MunPrivacyPrivate = 1
} MunPrivacy;

typedef uint8_t MunPrivacy_t;

typedef struct
{
    const char *name;
    const MunTypeInfo *arg_types;
    const MunTypeInfo *return_type;
    const void *fn_ptr;
    uint16_t num_arg_types;
    MunPrivacy_t privacy;
} MunFunctionInfo;

typedef struct
{
    const MunFunctionInfo *functions;
    uint32_t num_functions;
} MunModuleInfo;

#endif
```

## LLVM vs C ABI
Every assembly contains a get_symbol function that returns symbols for the top-level module as
a MunModuleInfo. As the Mun compiler already has a syntax tree of all function signatures and
types in the assembly, we can easily generate the required symbols. Or so we thought.
When we tested our compiled assembly in the Rust-written runtime, the returned MunModuleInfo
contained corrupted data. After a search down the internet rabbit hole, we discovered the cause.
Take this function:

```
MunModuleInfo get_symbols()
```

Based on our understanding of LLVM, we generated the following IR:

```
define %struct.MunModuleInfo @get_symbols()
```

To discover possible discrepencies with C-style IR we ran clang (clang -S -emit-llvm main.c),
resulting in this output:

```
define void @get_symbols(%struct.MunModuleInfo* noalias sret)
```

It turns out that the sret identifier is the culprit here. sret - which stands for StructReturn - is apparently the way structs larger than the native pointer size should be returned from C-style functions.

## Type GUIDs
> Bas: Write a short paragraph about how you hashed type names using md5